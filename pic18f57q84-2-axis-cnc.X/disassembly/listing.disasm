Disassembly Listing for stepper_test
Generated From:
C:/Users/C17239/MPLABXProjects/stepper_test.X/dist/default/production/stepper_test.X.production.elf
Apr 21, 2020 12:12:38 PM

---  C:/Users/C17239/MPLABXProjects/stepper_test.X/stepper.c  -------------------------------------------
1:             /*
2:                 (c) 2019 Microchip Technology Inc. and its subsidiaries. 
3:                 
4:                 Subject to your compliance with these terms, you may use Microchip software and any 
5:                 derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
6:                 license terms applicable to your use of third party software (including open source software) that 
7:                 may accompany Microchip software.
8:                 
9:                 THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
10:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
11:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
12:                FOR A PARTICULAR PURPOSE.
13:                
14:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
15:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
16:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
17:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
18:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
19:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
20:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
21:                SOFTWARE.
22:             */
23:            
24:            /******************************************************/
25:            
26:            #include "stepper.h"
27:            #include "hal.h"
28:            #include "mcc_generated_files/mcc.h"
29:            #include "config_macros.h"
30:            #include <stdlib.h>
31:            
32:            /******************************************************/
33:            
34:            #define FAST_TIME 1500
35:            #define SLOW_TIME 4
36:            
37:            #define HOMING_BACKUP 100
38:            #define HOME_MARGIN 10
39:            
40:            /******************************************************/
41:            
42:            void select_stepper_clc(Stepper stepper) {
43:                CLCSELECT = stepper.step.clc;
0A1E  F414     NOP
0A20  F0D5     NOP
44:            }
0A22  0012     RETURN 0
45:            
46:            /******************************************************/
47:            
48:            void enable_stepper_nco(Stepper stepper) {
49:                enable_nco(stepper.step.clock.nco);
0914  EE21     LFSR 2, 0x50C
0916  F10C     NOP
0918  EE01     LFSR 0, 0x501
091A  F101     NOP
091C  0E05     MOVLW 0x5
091E  C4DB     MOVFF PLUSW2, PLUSW0
0920  F4EB     NOP
0922  06E8     DECF 0xFE8, F, ACCESS
0924  E2FC     BC 0x91E
0926  ECE9     CALL 0x9D2, 0
0928  F004     NOP
50:            }
092A  0012     RETURN 0
51:            
52:            /******************************************************/
53:            
54:            void disable_stepper_nco(Stepper stepper) {
55:                disable_nco(stepper.step.clock.nco);
56:            }
57:            
58:            /******************************************************/
59:            
60:            void advance_stepper_manual() {
61:                CLCnPOLbits.POL = 1;
62:                __delay_us(FAST_TIME);
63:                CLCnPOLbits.POL = 0;
64:                __delay_us(FAST_TIME);
65:            }
66:            
67:            /******************************************************/
68:            
69:            void advance_stepper_manual_slow() {
70:                CLCnPOLbits.POL = 1;
71:                __delay_ms(SLOW_TIME);
72:                CLCnPOLbits.POL = 0;
73:                __delay_ms(SLOW_TIME);
74:            }
75:            
76:            /******************************************************/
77:            
78:            void set_stepper_forwards(Stepper stepper) {
79:                if(stepper.reversed){
80:                    set_low(stepper.direction);
81:                } else {
82:                    set_high(stepper.direction);
83:                }
84:            }
85:            
86:            /******************************************************/
87:            
88:            void set_stepper_backwards(Stepper stepper) {
89:                if(stepper.reversed){
90:                    set_high(stepper.direction);
91:                } else {
92:                    set_low(stepper.direction);
93:                }
94:            }
95:            
96:            /******************************************************/
97:            
98:            StepperError home_stepper(Stepper * stepper) {
99:                select_stepper_clc(*stepper);
100:               
101:               // Back up until it hits the limit switch
102:               set_stepper_backwards(*stepper);
103:               while (!get_pin(stepper->limit)) {
104:                   advance_stepper_manual();
105:               }
106:           
107:               // Get a slight bit away from the limit switch
108:               set_stepper_forwards(*stepper);
109:               uint8_t i;
110:               for (i = 0; i < HOMING_BACKUP; i++) {
111:                   advance_stepper_manual();
112:               }
113:           
114:               // Check if switch is still considered pressed after backing up
115:               // If so, something is wrong, error out
116:               if (get_pin(stepper->limit)) {
117:                   return HOMING_ERROR;
118:               }
119:           
120:               // Slowly back up until it hits the limit switch again
121:               set_stepper_backwards(*stepper);
122:               while (!get_pin(stepper->limit)) {
123:                   advance_stepper_manual_slow();
124:               }
125:           
126:               // Give a little bit of margin off the limit switch
127:               set_stepper_forwards(*stepper);
128:               for (i = 0; i < HOME_MARGIN; i++) {
129:                   advance_stepper_manual();
130:               }
131:           
132:               // Stepper position is now homed
133:               stepper->position = 0;
134:           
135:               return NO_ERROR;
136:           }
137:           
138:           /******************************************************/
139:           
140:           StepperError go_steps_manual(Stepper * stepper, int16_t steps) {
141:               StepperError error = NO_ERROR;
142:           
143:               uint16_t magnitude = abs(steps);
144:               
145:               select_stepper_clc(*stepper);
146:           
147:               if (steps >= 0) {
148:                   set_stepper_forwards(*stepper);
149:                   uint16_t target = stepper->position + magnitude;
150:           
151:                   if (target > stepper->maximum) {
152:                       error = OUT_OF_BOUNDS;
153:                       magnitude = stepper->maximum - stepper->position;
154:                   }
155:           
156:                   stepper->position += magnitude;
157:           
158:               } else {
159:                   set_stepper_backwards(*stepper);
160:                   if (magnitude > stepper->position) {
161:                       error = OUT_OF_BOUNDS;
162:                       magnitude = stepper->position;
163:                   }
164:           
165:                   stepper->position -= magnitude;
166:               }
167:           
168:               uint16_t i;
169:               for (i = 0; i < magnitude; i++) {
170:                   advance_stepper_manual();
171:               }
172:           
173:               return error;
174:           }
175:           
176:           /******************************************************/
177:           
178:           void set_stepper_nco_src(Stepper stepper, uint8_t source) {
179:               set_nco_source(stepper.step.clock.nco, source);
08C6  EE21     LFSR 2, 0x50D
08C8  F10D     NOP
08CA  EE01     LFSR 0, 0x501
08CC  F101     NOP
08CE  0E05     MOVLW 0x5
08D0  C4DB     MOVFF PLUSW2, PLUSW0
08D2  F4EB     NOP
08D4  06E8     DECF 0xFE8, F, ACCESS
08D6  E2FC     BC 0x8D0
08DA  F48C     NOP
08DC  F507     NOP
08DE  ECC3     CALL 0x986, 0
08E0  F004     NOP
180:           }
08E2  0012     RETURN 0
181:           
182:           /******************************************************/
183:           
184:           void set_stepper_nco_inc(Stepper stepper, uint32_t value) {
185:               set_nco_inc(stepper.step.clock.nco, value);
082C  EE21     LFSR 2, 0x510
082E  F110     NOP
0830  EE01     LFSR 0, 0x501
0832  F101     NOP
0834  0E05     MOVLW 0x5
0836  C4DB     MOVFF PLUSW2, PLUSW0
0838  F4EB     NOP
083A  06E8     DECF 0xFE8, F, ACCESS
083C  E2FC     BC 0x836
0840  F498     NOP
0842  F507     NOP
0846  F49C     NOP
0848  F508     NOP
084C  F4A0     NOP
084E  F509     NOP
0852  F4A4     NOP
0854  F50A     NOP
0856  ECC7     CALL 0x78E, 0
0858  F003     NOP
186:           }
085A  0012     RETURN 0
187:           
188:           /******************************************************/
189:           
190:           Stepper InitializeStepper(uint16_t maximum, Pin enable, StepPin step, Pin direction, Pin limit, bool reversed) {
191:               make_output(enable);
0248  EE21     LFSR 2, 0x524
024A  F124     NOP
024C  EE01     LFSR 0, 0x505
024E  F105     NOP
0250  0E06     MOVLW 0x6
0252  C4DB     MOVFF PLUSW2, PLUSW0
0254  F4EB     NOP
0256  06E8     DECF 0xFE8, F, ACCESS
0258  E2FC     BC 0x252
025A  EC96     CALL 0x92C, 0
025C  F004     NOP
192:           
193:               make_output(direction);
025E  EE21     LFSR 2, 0x533
0260  F133     NOP
0262  EE01     LFSR 0, 0x505
0264  F105     NOP
0266  0E06     MOVLW 0x6
0268  C4DB     MOVFF PLUSW2, PLUSW0
026A  F4EB     NOP
026C  06E8     DECF 0xFE8, F, ACCESS
026E  E2FC     BC 0x268
0270  EC96     CALL 0x92C, 0
0272  F004     NOP
194:           
195:               make_input(limit);
0274  EE21     LFSR 2, 0x53A
0276  F13A     NOP
0278  EE01     LFSR 0, 0x505
027A  F105     NOP
027C  0E06     MOVLW 0x6
027E  C4DB     MOVFF PLUSW2, PLUSW0
0280  F4EB     NOP
0282  06E8     DECF 0xFE8, F, ACCESS
0284  E2FC     BC 0x27E
0286  ECFD     CALL 0x7FA, 0
0288  F003     NOP
196:           
197:               Stepper stepper = {0, maximum, step, direction, limit, reversed};
028A  EE21     LFSR 2, 0x67E
028C  F27E     NOP
028E  EE11     LFSR 1, 0x542
0290  F142     NOP
0292  0E1A     MOVLW 0x1A
0294  C4DB     MOVFF PLUSW2, PLUSW1
0296  F4E3     NOP
0298  06E8     DECF 0xFE8, F, ACCESS
029A  E2FC     BC 0x294
029C  0E00     MOVLW 0x0
029E  6E43     MOVWF NVMADR, ACCESS
02A0  0E00     MOVLW 0x0
02A2  6E42     MOVWF NVMLOCK, ACCESS
02A6  F488     NOP
02A8  F544     NOP
02AC  F48C     NOP
02AE  F545     NOP
02B0  EE21     LFSR 2, 0x52B
02B2  F12B     NOP
02B4  EE11     LFSR 1, 0x546
02B6  F146     NOP
02B8  0E07     MOVLW 0x7
02BA  C4DB     MOVFF PLUSW2, PLUSW1
02BC  F4E3     NOP
02BE  06E8     DECF 0xFE8, F, ACCESS
02C0  E2FC     BC 0x2BA
02C2  EE21     LFSR 2, 0x533
02C4  F133     NOP
02C6  EE11     LFSR 1, 0x54E
02C8  F14E     NOP
02CA  0E06     MOVLW 0x6
02CC  C4DB     MOVFF PLUSW2, PLUSW1
02CE  F4E3     NOP
02D0  06E8     DECF 0xFE8, F, ACCESS
02D2  E2FC     BC 0x2CC
02D4  EE21     LFSR 2, 0x53A
02D6  F13A     NOP
02D8  EE11     LFSR 1, 0x555
02DA  F155     NOP
02DC  0E06     MOVLW 0x6
02DE  C4DB     MOVFF PLUSW2, PLUSW1
02E0  F4E3     NOP
02E2  06E8     DECF 0xFE8, F, ACCESS
02E4  E2FC     BC 0x2DE
02E8  F504     NOP
02EA  F55C     NOP
198:               
199:               select_stepper_clc(stepper);
02EC  EE21     LFSR 2, 0x542
02EE  F142     NOP
02F0  EE01     LFSR 0, 0x501
02F2  F101     NOP
02F4  0E1A     MOVLW 0x1A
02F6  C4DB     MOVFF PLUSW2, PLUSW0
02F8  F4EB     NOP
02FA  06E8     DECF 0xFE8, F, ACCESS
02FC  E2FC     BC 0x2F6
02FE  EC0E     CALL 0xA1C, 0
0300  F005     NOP
200:               
201:               CLCnCONbits.MODE = 0b010;
0302  0100     MOVLB 0x0
0304  51D6     MOVF CLCnCON, W, BANKED
0306  0BF8     ANDLW 0xF8
0308  0902     IORLW 0x2
030A  6FD6     MOVWF CLCnCON, BANKED
202:               CLCnSEL0 = MASTER_TIMER_SOURCE;
030C  0E4C     MOVLW 0x4C
030E  6FD8     MOVWF CLCnSEL0, BANKED
203:               CLCnCONbits.EN = 1;
0310  8FD6     BSF CLCnCON, 7, BANKED
204:               
205:               CLCnGLS0bits.G1D1T = 1;
0312  83DC     BSF CLCnGLS0, 1, BANKED
206:               
207:               CLCnPOLbits.G1POL = 0;
0314  91D7     BCF CLCnPOL, 0, BANKED
208:               CLCnPOLbits.G2POL = 1;
0316  83D7     BSF CLCnPOL, 1, BANKED
209:               CLCnPOLbits.G3POL = 0;
0318  95D7     BCF CLCnPOL, 2, BANKED
210:               CLCnPOLbits.G4POL = 0;
031A  97D7     BCF CLCnPOL, 3, BANKED
211:               
212:               set_high(enable);
031C  EE21     LFSR 2, 0x524
031E  F124     NOP
0320  EE01     LFSR 0, 0x504
0322  F104     NOP
0324  0E06     MOVLW 0x6
0326  C4DB     MOVFF PLUSW2, PLUSW0
0328  F4EB     NOP
032A  06E8     DECF 0xFE8, F, ACCESS
032C  E2FC     BC 0x326
032E  EC7E     CALL 0x8FC, 0
0330  F004     NOP
213:               
214:               enable_stepper_nco(stepper);
0332  EE21     LFSR 2, 0x542
0334  F142     NOP
0336  EE01     LFSR 0, 0x507
0338  F107     NOP
033A  0E1A     MOVLW 0x1A
033C  C4DB     MOVFF PLUSW2, PLUSW0
033E  F4EB     NOP
0340  06E8     DECF 0xFE8, F, ACCESS
0342  E2FC     BC 0x33C
0344  EC8A     CALL 0x914, 0
0346  F004     NOP
215:           
216:               return stepper;
0348  EE21     LFSR 2, 0x542
034A  F142     NOP
034C  EE01     LFSR 0, 0x522
034E  F122     NOP
0350  0E1A     MOVLW 0x1A
0352  C4DB     MOVFF PLUSW2, PLUSW0
0354  F4EB     NOP
0356  06E8     DECF 0xFE8, F, ACCESS
0358  E2FC     BC 0x352
217:           }
035A  0012     RETURN 0
218:           
219:           /******************************************************/
220:           
221:           StepPin InitializeStepPin(uint8_t group, uint8_t position, SlaveClock clock, uint8_t clc) {
043A  6E20     MOVWF 0x20, ACCESS
222:               Pin base_pin = InitializePin(group, position);
043E  F45C     NOP
0440  F501     NOP
0442  5020     MOVF 0x20, W, ACCESS
0444  ECA5     CALL 0x54A, 0
0446  F002     NOP
0448  EE21     LFSR 2, 0x521
044A  F121     NOP
044C  0E06     MOVLW 0x6
044E  C4EB     MOVFF PLUSW0, PLUSW2
0450  F4DB     NOP
0452  06E8     DECF 0xFE8, F, ACCESS
0454  E2FC     BC 0x44E
223:               make_output(base_pin);
0456  EE21     LFSR 2, 0x521
0458  F121     NOP
045A  EE01     LFSR 0, 0x505
045C  F105     NOP
045E  0E06     MOVLW 0x6
0460  C4DB     MOVFF PLUSW2, PLUSW0
0462  F4EB     NOP
0464  06E8     DECF 0xFE8, F, ACCESS
0466  E2FC     BC 0x460
0468  EC96     CALL 0x92C, 0
046A  F004     NOP
224:               
225:               set_pps(base_pin, CLC_1_OUT + clc);
046C  EE21     LFSR 2, 0x521
046E  F121     NOP
0470  EE01     LFSR 0, 0x501
0472  F101     NOP
0474  0E06     MOVLW 0x6
0476  C4DB     MOVFF PLUSW2, PLUSW0
0478  F4EB     NOP
047A  06E8     DECF 0xFE8, F, ACCESS
047C  E2FC     BC 0x476
047E  281F     INCF 0x1F, W, ACCESS
0480  6E08     MOVWF 0x8, ACCESS
0482  ECE3     CALL 0x7C6, 0
0484  F003     NOP
226:           
227:               StepPin step_pin = {clc, clock};
0486  EE21     LFSR 2, 0x560
0488  F160     NOP
048A  EE11     LFSR 1, 0x528
048C  F128     NOP
048E  0E07     MOVLW 0x7
0490  C4DB     MOVFF PLUSW2, PLUSW1
0492  F4E3     NOP
0494  06E8     DECF 0xFE8, F, ACCESS
0496  E2FC     BC 0x490
049A  F47C     NOP
049C  F528     NOP
049E  EE21     LFSR 2, 0x518
04A0  F118     NOP
04A2  EE11     LFSR 1, 0x529
04A4  F129     NOP
04A6  0E06     MOVLW 0x6
04A8  C4DB     MOVFF PLUSW2, PLUSW1
04AA  F4E3     NOP
04AC  06E8     DECF 0xFE8, F, ACCESS
04AE  E2FC     BC 0x4A8
228:           
229:               return step_pin;
04B0  EE21     LFSR 2, 0x528
04B2  F128     NOP
04B4  EE01     LFSR 0, 0x517
04B6  F117     NOP
04B8  0E07     MOVLW 0x7
04BA  C4DB     MOVFF PLUSW2, PLUSW0
04BC  F4EB     NOP
04BE  06E8     DECF 0xFE8, F, ACCESS
04C0  E2FC     BC 0x4BA
230:           }
04C2  0012     RETURN 0
231:           
232:           /******************************************************/
---  C:/Users/C17239/MPLABXProjects/stepper_test.X/slave_clock.c  ---------------------------------------
1:             /*
2:                 (c) 2019 Microchip Technology Inc. and its subsidiaries. 
3:                 
4:                 Subject to your compliance with these terms, you may use Microchip software and any 
5:                 derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
6:                 license terms applicable to your use of third party software (including open source software) that 
7:                 may accompany Microchip software.
8:                 
9:                 THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
10:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
11:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
12:                FOR A PARTICULAR PURPOSE.
13:                
14:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
15:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
16:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
17:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
18:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
19:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
20:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
21:                SOFTWARE.
22:             */
23:            
24:            /******************************************************/
25:            
26:            #include "slave_clock.h"
27:            #include "config_macros.h"
28:            
29:            /******************************************************/
30:            
31:            SlaveClock CreateSlaveClock(RegisterPtr nco, uint8_t nco_pps){
32:                RegisterPtr inc = nco + NCO_INC_OFFSET;
04C4  0EFC     MOVLW 0xFC
04C6  2401     ADDWF 0x1, W, ACCESS
04C8  6E08     MOVWF 0x8, ACCESS
04CA  0EFF     MOVLW 0xFF
04CC  2002     ADDWFC 0x2, W, ACCESS
04CE  6E09     MOVWF 0x9, ACCESS
33:                RegisterPtr con = nco + NCO_CON_OFFSET;
04D0  0EFF     MOVLW 0xFF
04D2  2401     ADDWF 0x1, W, ACCESS
04D4  6E0A     MOVWF 0xA, ACCESS
04D6  0EFF     MOVLW 0xFF
04D8  2002     ADDWFC 0x2, W, ACCESS
04DA  6E0B     MOVWF 0xB, ACCESS
34:                RegisterPtr clk = nco + NCO_CLK_OFFSET;
04DE  F404     NOP
04E0  F50C     NOP
04E4  F408     NOP
04E6  F50D     NOP
35:                
36:                NCO osc = {clk, inc, con};
04EA  F430     NOP
04EC  F515     NOP
04F0  F434     NOP
04F2  F516     NOP
04F6  F420     NOP
04F8  F517     NOP
04FC  F424     NOP
04FE  F518     NOP
0502  F428     NOP
0504  F519     NOP
0508  F42C     NOP
050A  F51A     NOP
37:                
38:                SlaveClock slave_clock = {osc, nco_pps};
050C  EE21     LFSR 2, 0x568
050E  F168     NOP
0510  EE11     LFSR 1, 0x50E
0512  F10E     NOP
0514  0E06     MOVLW 0x6
0516  C4DB     MOVFF PLUSW2, PLUSW1
0518  F4E3     NOP
051A  06E8     DECF 0xFE8, F, ACCESS
051C  E2FC     BC 0x516
051E  EE21     LFSR 2, 0x515
0520  F115     NOP
0522  EE11     LFSR 1, 0x50E
0524  F10E     NOP
0526  0E05     MOVLW 0x5
0528  C4DB     MOVFF PLUSW2, PLUSW1
052A  F4E3     NOP
052C  06E8     DECF 0xFE8, F, ACCESS
052E  E2FC     BC 0x528
0532  F40C     NOP
0534  F514     NOP
39:                
40:                return slave_clock;
0536  EE21     LFSR 2, 0x50E
0538  F10E     NOP
053A  EE01     LFSR 0, 0x501
053C  F101     NOP
053E  0E06     MOVLW 0x6
0540  C4DB     MOVFF PLUSW2, PLUSW0
0542  F4EB     NOP
0544  06E8     DECF 0xFE8, F, ACCESS
0546  E2FC     BC 0x540
41:            }
0548  0012     RETURN 0
42:            
43:            void enable_nco(NCO nco){
44:                *nco.con |= 0x80;
09D4  F414     NOP
09D6  F4D9     NOP
09DA  F418     NOP
09DC  F4DA     NOP
09DE  0E00     MOVLW 0x0
09E0  8EDB     BSF 0xFDB, 7, ACCESS
45:            }
09E2  0012     RETURN 0
46:            
47:            void disable_nco(NCO nco){
48:                *nco.con &= 0x7F;
49:            }
50:            
51:            void set_nco_source(NCO nco, uint8_t source){
52:                *nco.src = source;
0988  F404     NOP
098A  F4D9     NOP
098E  F408     NOP
0990  F4DA     NOP
0994  F41C     NOP
0996  F4DF     NOP
53:            }
0998  0012     RETURN 0
54:            
55:            void set_nco_inc(NCO nco, uint32_t value){
56:                *(nco.inc + 2) = (value >> 16) & 0xFF;
078E  EE20     LFSR 2, 0x2
0790  F002     NOP
0792  5003     MOVF 0x3, W, ACCESS
0794  26D9     ADDWF 0xFD9, F, ACCESS
0796  5004     MOVF 0x4, W, ACCESS
0798  22DA     ADDWFC 0xFDA, F, ACCESS
079C  F424     NOP
079E  F4DF     NOP
57:                *(nco.inc + 1) = (value >> 8) & 0xFF;
07A0  EE20     LFSR 2, 0x1
07A2  F001     NOP
07A4  5003     MOVF 0x3, W, ACCESS
07A6  26D9     ADDWF 0xFD9, F, ACCESS
07A8  5004     MOVF 0x4, W, ACCESS
07AA  22DA     ADDWFC 0xFDA, F, ACCESS
07AE  F420     NOP
07B0  F4DF     NOP
58:                *nco.inc = value & 0xFF;
07B4  F40C     NOP
07B6  F4D9     NOP
07BA  F410     NOP
07BC  F4DA     NOP
07C0  F41C     NOP
07C2  F4DF     NOP
59:            }
07C4  0012     RETURN 0
---  C:/Users/C17239/MPLABXProjects/stepper_test.X/platform.c  ------------------------------------------
1:             /*
2:                 (c) 2019 Microchip Technology Inc. and its subsidiaries. 
3:                 
4:                 Subject to your compliance with these terms, you may use Microchip software and any 
5:                 derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
6:                 license terms applicable to your use of third party software (including open source software) that 
7:                 may accompany Microchip software.
8:                 
9:                 THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
10:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
11:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
12:                FOR A PARTICULAR PURPOSE.
13:                
14:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
15:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
16:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
17:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
18:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
19:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
20:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
21:                SOFTWARE.
22:             */
23:            
24:            /******************************************************/
25:            
26:            #include "platform.h"
27:            #include "config_macros.h"
28:            #include "master_clock.h"
29:            
30:            /******************************************************/
31:            
32:            Stepper y_axis;
33:            Stepper x_axis;
34:            
35:            void null_cb(){
36:            }
0A50  0012     RETURN 0
37:            
38:            CbFuncPtr counter_cb = &null_cb;
39:            CbFuncPtr ramp_dma_cb = &null_cb;
40:            
41:            void ramp_isr_ramp_up(void);
42:            void ramp_isr_ramp_down(void);
43:            
44:            void InitializePlatform(Stepper x_stepper, Stepper y_stepper) {
45:                x_axis = x_stepper;
06A8  EE21     LFSR 2, 0x5B2
06AA  F1B2     NOP
06AC  EE11     LFSR 1, 0x57C
06AE  F17C     NOP
06B0  0E1A     MOVLW 0x1A
06B2  C4DB     MOVFF PLUSW2, PLUSW1
06B4  F4E3     NOP
06B6  06E8     DECF 0xFE8, F, ACCESS
06B8  E2FC     BC 0x6B2
46:                y_axis = y_stepper;
06BA  EE21     LFSR 2, 0x5CD
06BC  F1CD     NOP
06BE  EE11     LFSR 1, 0x597
06C0  F197     NOP
06C2  0E1A     MOVLW 0x1A
06C4  C4DB     MOVFF PLUSW2, PLUSW1
06C6  F4E3     NOP
06C8  06E8     DECF 0xFE8, F, ACCESS
06CA  E2FC     BC 0x6C4
47:                set_stepper_nco_src(y_axis, MASTER_NCO_SOURCE);
06CC  EE21     LFSR 2, 0x597
06CE  F197     NOP
06D0  EE01     LFSR 0, 0x508
06D2  F108     NOP
06D4  0E1A     MOVLW 0x1A
06D6  C4DB     MOVFF PLUSW2, PLUSW0
06D8  F4EB     NOP
06DA  06E8     DECF 0xFE8, F, ACCESS
06DC  E2FC     BC 0x6D6
06DE  0E12     MOVLW 0x12
06E0  6E23     MOVWF 0x23, ACCESS
06E2  EC63     CALL 0x8C6, 0
06E4  F004     NOP
48:                set_stepper_nco_src(x_axis, MASTER_NCO_SOURCE);
06E6  EE21     LFSR 2, 0x57C
06E8  F17C     NOP
06EA  EE01     LFSR 0, 0x508
06EC  F108     NOP
06EE  0E1A     MOVLW 0x1A
06F0  C4DB     MOVFF PLUSW2, PLUSW0
06F2  F4EB     NOP
06F4  06E8     DECF 0xFE8, F, ACCESS
06F6  E2FC     BC 0x6F0
06F8  0E12     MOVLW 0x12
06FA  6E23     MOVWF 0x23, ACCESS
06FC  EC63     CALL 0x8C6, 0
06FE  F004     NOP
49:            }
0700  0012     RETURN 0
50:            
51:            /******************************************************/
52:            
53:            StepperError home_platform() {
54:                
55:                StepperError error;
56:            
57:                error = home_stepper(&x_axis);
58:                if (error != NO_ERROR) {
59:                    return error;
60:                }
61:            
62:                error = home_stepper(&y_axis);
63:                if (error != NO_ERROR) {
64:                    return error;
65:                }
66:                
67:                return error;
68:            }
69:            
70:            /******************************************************/
71:            
72:            void set_xy_inc(uint32_t x, uint32_t y){
73:                set_stepper_nco_inc(x_axis, x);
064A  EE21     LFSR 2, 0x57C
064C  F17C     NOP
064E  EE01     LFSR 0, 0x50B
0650  F10B     NOP
0652  0E1A     MOVLW 0x1A
0654  C4DB     MOVFF PLUSW2, PLUSW0
0656  F4EB     NOP
0658  06E8     DECF 0xFE8, F, ACCESS
065A  E2FC     BC 0x654
065E  F4A8     NOP
0660  F526     NOP
0664  F4AC     NOP
0666  F527     NOP
066A  F4B0     NOP
066C  F528     NOP
0670  F4B4     NOP
0672  F529     NOP
0674  EC16     CALL 0x82C, 0
0676  F004     NOP
74:                set_stepper_nco_inc(y_axis, y);
0678  EE21     LFSR 2, 0x597
067A  F197     NOP
067C  EE01     LFSR 0, 0x50B
067E  F10B     NOP
0680  0E1A     MOVLW 0x1A
0682  C4DB     MOVFF PLUSW2, PLUSW0
0684  F4EB     NOP
0686  06E8     DECF 0xFE8, F, ACCESS
0688  E2FC     BC 0x682
068C  F4B8     NOP
068E  F526     NOP
0692  F4BC     NOP
0694  F527     NOP
0698  F4C0     NOP
069A  F528     NOP
069E  F4C4     NOP
06A0  F529     NOP
06A2  EC16     CALL 0x82C, 0
06A4  F004     NOP
75:            }
06A6  0012     RETURN 0
76:            
77:            void counter_isr(){
78:                (*counter_cb)();
08A6  D801     RCALL 0x8AA
08A8  D00B     BRA 0x8C0
08AA  0005     PUSH
08AC  6EFA     MOVWF 0xFFA, ACCESS
08AE  0105     MOVLB 0x5
08B0  51EB     MOVF DMAnDCNTH, W, BANKED
08B2  6EFD     MOVWF 0xFFD, ACCESS
08B4  51EC     MOVF DMAnDPTR, W, BANKED
08B6  6EFE     MOVWF 0xFFE, ACCESS
08B8  51ED     MOVF DMAnDPTRH, W, BANKED
08BA  6EFF     MOVWF 0xFFF, ACCESS
08BC  50FA     MOVF 0xFFA, W, ACCESS
08BE  0012     RETURN 0
79:                clear_counter_isr();
08C0  EC26     CALL 0xA4C, 0
08C2  F005     NOP
80:            }
08C4  0012     RETURN 0
81:            
82:            // Interrupt because travel is complete
83:            void counter_isr_end(){
84:                disable_master_nco();
0A3C  EC21     CALL 0xA42, 0
0A3E  F005     NOP
85:            }
0A40  0012     RETURN 0
86:            
87:            // Interrupt because midpoint was reached
88:            void counter_isr_ramp_up(){
89:                counter_cb = &counter_isr_end;
90:            }
91:            
92:            // Interrupt because it needs to start slowing down
93:            void counter_isr_full_speed(){
94:                counter_cb = &counter_isr_end;
0A02  0E3C     MOVLW 0x3C
0A04  6FEB     MOVWF DMAnDCNTH, BANKED
0A06  0E0A     MOVLW 0xA
0A08  6FEC     MOVWF DMAnDPTR, BANKED
0A0A  0E00     MOVLW 0x0
0A0C  6FED     MOVWF DMAnDPTRH, BANKED
95:            }
0A0E  0012     RETURN 0
96:            
97:            // Interrupt because full speed reached
98:            void ramp_isr_ramp_up(){
99:                ramp_dma_cb = &ramp_isr_ramp_down;
100:               // figure out how much further to go
101:               uint16_t distance = 5; // distance until start ramp down
102:               start_counter(distance);
103:               counter_cb = &counter_isr_full_speed;
104:           }
105:           
106:           // Interrupt because minimum speed reached
107:           void ramp_isr_ramp_down(){
108:               ramp_dma_cb = &ramp_isr_ramp_up;
109:           }
110:           
111:           void travel_fixed_speed(uint16_t distance, uint32_t inc){
112:               counter_cb = &counter_isr_end;
074E  0E3C     MOVLW 0x3C
0750  0105     MOVLB 0x5
0752  6FEB     MOVWF DMAnDCNTH, BANKED
0754  0E0A     MOVLW 0xA
0756  6FEC     MOVWF DMAnDPTR, BANKED
0758  0E00     MOVLW 0x0
075A  6FED     MOVWF DMAnDPTRH, BANKED
113:               start_counter(distance);
075E  F414     NOP
0760  F503     NOP
0764  F418     NOP
0766  F504     NOP
0768  ECAE     CALL 0x95C, 0
076A  F004     NOP
114:               set_master_nco_inc(inc);
076E  F41C     NOP
0770  F501     NOP
0774  F420     NOP
0776  F502     NOP
077A  F424     NOP
077C  F503     NOP
0780  F428     NOP
0782  F504     NOP
0784  ECB9     CALL 0x972, 0
0786  F004     NOP
115:               enable_master_nco();
0788  EC15     CALL 0xA2A, 0
078A  F005     NOP
116:           }
078C  0012     RETURN 0
117:           
118:           void travel_ramp_speed(uint16_t distance, uint32_t max){
119:               counter_cb = &counter_isr_end;
120:               ramp_dma_cb = &ramp_isr_ramp_up;
121:               set_master_nco_inc(0);
122:               //Something to do with DMA
123:               enable_master_nco();
124:           }
---  C:/Users/C17239/MPLABXProjects/stepper_test.X/pin.c  -----------------------------------------------
1:             /*
2:                 (c) 2019 Microchip Technology Inc. and its subsidiaries. 
3:                 
4:                 Subject to your compliance with these terms, you may use Microchip software and any 
5:                 derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
6:                 license terms applicable to your use of third party software (including open source software) that 
7:                 may accompany Microchip software.
8:                 
9:                 THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
10:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
11:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
12:                FOR A PARTICULAR PURPOSE.
13:                
14:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
15:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
16:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
17:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
18:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
19:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
20:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
21:                SOFTWARE.
22:             */
23:            
24:            /******************************************************/
25:            
26:            #include "pin.h"
27:            #include <xc.h>
28:            
29:            #define SPACE_BETWEEN_GROUPS (&ANSELB - &ANSELA)
30:            
31:            /******************************************************/
32:            
33:            inline void set_bit(RegisterPtr reg, uint8_t mask) {
34:                *reg |= mask;
09C2  F404     NOP
09C4  F4D9     NOP
09C8  F408     NOP
09CA  F4DA     NOP
09CC  5003     MOVF 0x3, W, ACCESS
09CE  12DF     IORWF 0xFDF, F, ACCESS
35:            }
09D0  0012     RETURN 0
36:            
37:            /******************************************************/
38:            
39:            inline void clear_bit(RegisterPtr reg, uint8_t mask) {
40:                *reg &= ~mask;
0944  5003     MOVF 0x3, W, ACCESS
0946  0AFF     XORLW 0xFF
0948  6E04     MOVWF 0x4, ACCESS
094C  F404     NOP
094E  F4D9     NOP
0952  F408     NOP
0954  F4DA     NOP
0956  5004     MOVF 0x4, W, ACCESS
0958  16DF     ANDWF 0xFDF, F, ACCESS
41:            }
095A  0012     RETURN 0
42:            
43:            /******************************************************/
44:            
45:            void set_high(Pin pin) {
46:                set_bit(pin.lat, pin.mask);
08FE  F418     NOP
0900  F501     NOP
0904  F41C     NOP
0906  F502     NOP
090A  F424     NOP
090C  F503     NOP
090E  ECE0     CALL 0x9C0, 0
0910  F004     NOP
47:            }
0912  0012     RETURN 0
48:            
49:            /******************************************************/
50:            
51:            void set_low(Pin pin) {
52:                clear_bit(pin.lat, pin.mask);
53:            }
54:            
55:            /******************************************************/
56:            
57:            void make_output(Pin pin) {
58:                clear_bit(&TRISA + pin.group, pin.mask);
092C  0EC6     MOVLW 0xC6
092E  2409     ADDWF 0x9, W, ACCESS
0930  6E01     MOVWF 0x1, ACCESS
0932  6A02     CLRF 0x2, ACCESS
0934  0E04     MOVLW 0x4
0936  2202     ADDWFC 0x2, F, ACCESS
093A  F428     NOP
093C  F503     NOP
093E  ECA2     CALL 0x944, 0
0940  F004     NOP
59:            }
0942  0012     RETURN 0
60:            
61:            /******************************************************/
62:            
63:            void make_input(Pin pin) {
64:                clear_bit(&ANSELA + (pin.group * SPACE_BETWEEN_GROUPS), pin.mask);
07FA  5009     MOVF 0x9, W, ACCESS
07FC  0D08     MULLW 0x8
07FE  0E00     MOVLW 0x0
0800  24F3     ADDWF 0xFF3, W, ACCESS
0802  6E01     MOVWF 0x1, ACCESS
0804  0E04     MOVLW 0x4
0806  20F4     ADDWFC 0xFF4, W, ACCESS
0808  6E02     MOVWF 0x2, ACCESS
080C  F428     NOP
080E  F503     NOP
0810  ECA2     CALL 0x944, 0
0812  F004     NOP
65:                set_bit(&TRISA + pin.group, pin.mask);
0814  0EC6     MOVLW 0xC6
0816  2409     ADDWF 0x9, W, ACCESS
0818  6E01     MOVWF 0x1, ACCESS
081A  6A02     CLRF 0x2, ACCESS
081C  0E04     MOVLW 0x4
081E  2202     ADDWFC 0x2, F, ACCESS
0822  F428     NOP
0824  F503     NOP
0826  ECE0     CALL 0x9C0, 0
0828  F004     NOP
66:            }
082A  0012     RETURN 0
67:            
68:            /******************************************************/
69:            
70:            void set_pps(Pin pin, uint8_t value){
71:                RegisterPtr RxyPPS = &RA0PPS + (pin.group * 8) + pin.position;
07C6  5005     MOVF 0x5, W, ACCESS
07C8  0D08     MULLW 0x8
07CA  0E01     MOVLW 0x1
07CC  6E09     MOVWF 0x9, ACCESS
07CE  0E02     MOVLW 0x2
07D0  6E0A     MOVWF 0xA, ACCESS
07D2  50F3     MOVF 0xFF3, W, ACCESS
07D4  2609     ADDWF 0x9, F, ACCESS
07D6  50F4     MOVF 0xFF4, W, ACCESS
07D8  220A     ADDWFC 0xA, F, ACCESS
07DA  5007     MOVF 0x7, W, ACCESS
07DC  2409     ADDWF 0x9, W, ACCESS
07DE  6E0B     MOVWF 0xB, ACCESS
07E0  0E00     MOVLW 0x0
07E2  200A     ADDWFC 0xA, W, ACCESS
07E4  6E0C     MOVWF 0xC, ACCESS
72:                *RxyPPS = value;
07E8  F42C     NOP
07EA  F4D9     NOP
07EE  F430     NOP
07F0  F4DA     NOP
07F4  F420     NOP
07F6  F4DF     NOP
73:            }
07F8  0012     RETURN 0
74:            
75:            /******************************************************/
76:            
77:            bool get_pin(Pin pin) {
78:                if (*pin.port & pin.mask) {
79:                    return true;
80:                } else {
81:                    return false;
82:                }
83:            }
84:            
85:            /******************************************************/
86:            
87:            Pin InitializePin(uint8_t group, uint8_t position) {
054A  6E0F     MOVWF 0xF, ACCESS
88:                uint8_t mask = 1 << position;
054E  F404     NOP
0550  F508     NOP
0552  0E01     MOVLW 0x1
0554  6E09     MOVWF 0x9, ACCESS
0556  2A08     INCF 0x8, F, ACCESS
0558  D002     BRA 0x55E
055A  90D8     BCF 0xFD8, 0, ACCESS
055C  3609     RLCF 0x9, F, ACCESS
055E  2E08     DECFSZ 0x8, F, ACCESS
0560  D7FC     BRA 0x55A
0562  5009     MOVF 0x9, W, ACCESS
0564  6E0E     MOVWF 0xE, ACCESS
89:                RegisterPtr port = &PORTA + group;
0566  0ECE     MOVLW 0xCE
0568  240F     ADDWF 0xF, W, ACCESS
056A  6E0A     MOVWF 0xA, ACCESS
056C  6A0B     CLRF 0xB, ACCESS
056E  0E04     MOVLW 0x4
0570  220B     ADDWFC 0xB, F, ACCESS
90:                RegisterPtr lat = &LATA + group;
0572  0EBE     MOVLW 0xBE
0574  240F     ADDWF 0xF, W, ACCESS
0576  6E0C     MOVWF 0xC, ACCESS
0578  6A0D     CLRF 0xD, ACCESS
057A  0E04     MOVLW 0x4
057C  220D     ADDWFC 0xD, F, ACCESS
91:                Pin new_pin = {port, lat, group, mask, position};
057E  EE21     LFSR 2, 0x56F
0580  F16F     NOP
0582  EE11     LFSR 1, 0x510
0584  F110     NOP
0586  0E06     MOVLW 0x6
0588  C4DB     MOVFF PLUSW2, PLUSW1
058A  F4E3     NOP
058C  06E8     DECF 0xFE8, F, ACCESS
058E  E2FC     BC 0x588
0592  F428     NOP
0594  F510     NOP
0598  F42C     NOP
059A  F511     NOP
059E  F430     NOP
05A0  F512     NOP
05A4  F434     NOP
05A6  F513     NOP
05AA  F43C     NOP
05AC  F514     NOP
05B0  F438     NOP
05B2  F515     NOP
05B6  F404     NOP
05B8  F516     NOP
92:            
93:                return new_pin;
05BA  EE21     LFSR 2, 0x510
05BC  F110     NOP
05BE  EE01     LFSR 0, 0x501
05C0  F101     NOP
05C2  0E06     MOVLW 0x6
05C4  C4DB     MOVFF PLUSW2, PLUSW0
05C6  F4EB     NOP
05C8  06E8     DECF 0xFE8, F, ACCESS
05CA  E2FC     BC 0x5C4
94:            }
05CC  0012     RETURN 0
---  C:/Users/C17239/MPLABXProjects/stepper_test.X/mcc_generated_files/pin_manager.c  -------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.05 and above
21:                    MPLAB             :  MPLAB X 5.20
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            
51:            
52:            
53:            
54:            
55:            void PIN_MANAGER_Initialize(void)
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATE = 0x00;
05CE  0E00     MOVLW 0x0
05D0  6EC2     MOVWF 0xFC2, ACCESS
61:                LATD = 0x00;
05D2  0E00     MOVLW 0x0
05D4  6EC1     MOVWF 0xFC1, ACCESS
62:                LATA = 0x00;
05D6  0E00     MOVLW 0x0
05D8  6EBE     MOVWF 0xFBE, ACCESS
63:                LATB = 0x00;
05DA  0E00     MOVLW 0x0
05DC  6EBF     MOVWF 0xFBF, ACCESS
64:                LATC = 0x00;
05DE  0E00     MOVLW 0x0
05E0  6EC0     MOVWF 0xFC0, ACCESS
65:            
66:                /**
67:                TRISx registers
68:                */
69:                TRISE = 0x07;
05E2  0E07     MOVLW 0x7
05E4  6ECA     MOVWF 0xFCA, ACCESS
70:                TRISA = 0x71;
05E6  0E71     MOVLW 0x71
05E8  6EC6     MOVWF 0xFC6, ACCESS
71:                TRISB = 0xDE;
05EA  0EDE     MOVLW 0xDE
05EC  6EC7     MOVWF 0xFC7, ACCESS
72:                TRISC = 0xFB;
05EE  0EFB     MOVLW 0xFB
05F0  6EC8     MOVWF 0xFC8, ACCESS
73:                TRISD = 0xF0;
05F2  0EF0     MOVLW 0xF0
05F4  6EC9     MOVWF 0xFC9, ACCESS
74:            
75:                /**
76:                ANSELx registers
77:                */
78:                ANSELD = 0xFF;
05F6  0104     MOVLB 0x4
05F8  6918     SETF 0x18, BANKED
79:                ANSELC = 0xDF;
05FA  0EDF     MOVLW 0xDF
05FC  6F10     MOVWF 0x10, BANKED
80:                ANSELB = 0xEF;
05FE  0EEF     MOVLW 0xEF
0600  6F08     MOVWF 0x8, BANKED
81:                ANSELE = 0x07;
0602  0E07     MOVLW 0x7
0604  6F20     MOVWF 0x20, BANKED
82:                ANSELA = 0xFF;
0606  6900     SETF group, BANKED
83:            
84:                /**
85:                WPUx registers
86:                */
87:                WPUD = 0x00;
0608  0E00     MOVLW 0x0
060A  6F19     MOVWF 0x19, BANKED
88:                WPUE = 0x00;
060C  0E00     MOVLW 0x0
060E  6F21     MOVWF 0x21, BANKED
89:                WPUB = 0x10;
0610  0E10     MOVLW 0x10
0612  6F09     MOVWF 0x9, BANKED
90:                WPUA = 0x00;
0614  0E00     MOVLW 0x0
0616  6F01     MOVWF 0x1, BANKED
91:                WPUC = 0x00;
0618  0E00     MOVLW 0x0
061A  6F11     MOVWF 0x11, BANKED
92:            
93:                /**
94:                ODx registers
95:                */
96:                ODCONE = 0x00;
061C  0E00     MOVLW 0x0
061E  6F22     MOVWF 0x22, BANKED
97:                ODCONA = 0x00;
0620  0E00     MOVLW 0x0
0622  6F02     MOVWF 0x2, BANKED
98:                ODCONB = 0x00;
0624  0E00     MOVLW 0x0
0626  6F0A     MOVWF 0xA, BANKED
99:                ODCONC = 0x00;
0628  0E00     MOVLW 0x0
062A  6F12     MOVWF 0x12, BANKED
100:               ODCOND = 0x00;
062C  0E00     MOVLW 0x0
062E  6F1A     MOVWF 0x1A, BANKED
101:           
102:               /**
103:               SLRCONx registers
104:               */
105:               SLRCONA = 0xFF;
0630  6903     SETF 0x3, BANKED
106:               SLRCONB = 0xFF;
0632  690B     SETF 0xB, BANKED
107:               SLRCONC = 0xFF;
0634  6913     SETF 0x13, BANKED
108:               SLRCOND = 0xFF;
0636  691B     SETF 0x1B, BANKED
109:               SLRCONE = 0x07;
0638  0E07     MOVLW 0x7
063A  6F23     MOVWF 0x23, BANKED
110:           
111:               /**
112:               INLVLx registers
113:               */
114:               INLVLA = 0xFF;
063C  6904     SETF 0x4, BANKED
115:               INLVLB = 0xFF;
063E  690C     SETF 0xC, BANKED
116:               INLVLC = 0xFF;
0640  6914     SETF 0x14, BANKED
117:               INLVLD = 0xFF;
0642  691C     SETF 0x1C, BANKED
118:               INLVLE = 0x0F;
0644  0E0F     MOVLW 0xF
0646  6F24     MOVWF 0x24, BANKED
119:           
120:           
121:           
122:           
123:           
124:              
125:               
126:           }
0648  0012     RETURN 0
127:             
128:           void PIN_MANAGER_IOC(void)
129:           {   
130:           }
131:           
132:           /**
133:            End of File
134:           */
---  C:/Users/C17239/MPLABXProjects/stepper_test.X/mcc_generated_files/mcc.c  ---------------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.05 and above or later
21:                    MPLAB             :  MPLAB X 5.20
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:                PMD_Initialize();
09F4  EC41     CALL 0x882, 0
09F6  F004     NOP
53:                PIN_MANAGER_Initialize();
09F8  ECE7     CALL 0x5CE, 0
09FA  F002     NOP
54:                OSCILLATOR_Initialize();
09FC  EC72     CALL 0x8E4, 0
09FE  F004     NOP
55:            }
0A00  0012     RETURN 0
56:            
57:            void OSCILLATOR_Initialize(void)
58:            {
59:                // NOSC HFINTOSC; NDIV 1; 
60:                OSCCON1 = 0x60;
08E4  0E60     MOVLW 0x60
08E6  0100     MOVLB 0x0
08E8  6FAD     MOVWF OSCCON1, BANKED
61:                // CSWHOLD may proceed; SOSCPWR Low power; 
62:                OSCCON3 = 0x00;
08EA  0E00     MOVLW 0x0
08EC  6FAF     MOVWF OSCCON3, BANKED
63:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
64:                OSCEN = 0x00;
08EE  0E00     MOVLW 0x0
08F0  6FB3     MOVWF OSCEN, BANKED
65:                // HFFRQ 64_MHz; 
66:                OSCFRQ = 0x08;
08F2  0E08     MOVLW 0x8
08F4  6FB1     MOVWF OSCFRQ, BANKED
67:                // TUN 0; 
68:                OSCTUNE = 0x00;
08F6  0E00     MOVLW 0x0
08F8  6FB0     MOVWF OSCTUNE, BANKED
69:            }
08FA  0012     RETURN 0
70:            
71:            void PMD_Initialize(void)
72:            {
73:                // CLKRMD CLKR enabled; SYSCMD SYSCLK enabled; SCANMD SCANNER enabled; FVRMD FVR enabled; IOCMD IOC enabled; CRCMD CRC enabled; HLVDMD HLVD enabled; NVMMD NVM enabled; 
74:                PMD0 = 0x00;
0882  0E00     MOVLW 0x0
0884  0100     MOVLB 0x0
0886  6F60     MOVWF PMD0, BANKED
75:                // TMR0MD TMR0 enabled; TMR1MD TMR1 enabled; TMR4MD TMR4 enabled; SMT1MD SMT1 enabled; TMR5MD TMR5 enabled; TMR2MD TMR2 enabled; TMR3MD TMR3 enabled; TMR6MD TMR6 enabled; 
76:                PMD1 = 0x00;
0888  0E00     MOVLW 0x0
088A  6F61     MOVWF PMD1, BANKED
77:                // ZCDMD ZCD enabled; ADCMD ADC enabled; ACTMD ACT enabled; CM2MD CM2 enabled; CM1MD CM1 enabled; DAC1MD DAC1 enabled; 
78:                PMD3 = 0x00;
088C  0E00     MOVLW 0x0
088E  6F63     MOVWF PMD3, BANKED
79:                // NCO1MD NCO1 enabled; NCO2MD NCO2 enabled; DSM1MD DSM1 enabled; CWG3MD CWG3 enabled; CWG2MD CWG2 enabled; CWG1MD CWG1 enabled; NCO3MD NCO3 enabled; 
80:                PMD4 = 0x00;
0890  0E00     MOVLW 0x0
0892  6F64     MOVWF PMD4, BANKED
81:                // CCP2MD CCP2 enabled; CCP1MD CCP1 enabled; PWM2MD PWM2 enabled; CCP3MD CCP3 enabled; PWM1MD PWM1 enabled; PWM3MD PWM3 enabled; 
82:                PMD5 = 0x00;
0894  0E00     MOVLW 0x0
0896  6F65     MOVWF PMD5, BANKED
83:                // U5MD EUSART5 enabled; U4MD EUSART4 enabled; U3MD EUSART3 enabled; U2MD EUSART2 enabled; U1MD EUSART1 enabled; SPI2MD SPI2 enabled; SPI1MD SPI1 enabled; I2C1MD I2C1 enabled; 
84:                PMD6 = 0x00;
0898  0E00     MOVLW 0x0
089A  6F66     MOVWF PMD6, BANKED
85:                // CLC5MD CLC5 enabled; CLC6MD CLC6 enabled; CLC3MD CLC3 enabled; CLC4MD CLC4 enabled; CLC7MD CLC7 enabled; CLC8MD CLC8 enabled; CLC1MD CLC1 enabled; CLC2MD CLC2 enabled; 
86:                PMD7 = 0x00;
089C  0E00     MOVLW 0x0
089E  6F67     MOVWF PMD7, BANKED
87:                // DMA5MD DMA5 enabled; DMA6MD DMA6 enabled; DMA1MD DMA1 enabled; DMA2MD DMA2 enabled; DMA3MD DMA3 enabled; DMA4MD DMA4 enabled; 
88:                PMD8 = 0x00;
08A0  0E00     MOVLW 0x0
08A2  6F68     MOVWF PMD8, BANKED
89:            }
08A4  0012     RETURN 0
90:            
91:            
92:            /**
93:             End of File
94:            */
---  C:/Users/C17239/MPLABXProjects/stepper_test.X/master_clock.c  --------------------------------------
1:             /*
2:              * File:   master_nco.c
3:              * Author: C17239
4:              *
5:              * Created on March 24, 2020, 11:28 AM
6:              */
7:             
8:             #include "master_clock.h"
9:             #include "config_macros.h"
10:            #include "counter.h"
11:            
12:            #define ENABLE_BIT 0x80;
13:            
14:            void InitializeMasterClock() {
15:                initialize_counter();
0A36  EC2E     CALL 0x85C, 0
0A38  F004     NOP
16:            }
0A3A  0012     RETURN 0
17:            
18:            inline void set_master_nco_inc(uint32_t value){
19:                MASTER_NCO_INC = value;
0974  F404     NOP
0976  F453     NOP
097A  F408     NOP
097C  F454     NOP
0980  F40C     NOP
0982  F455     NOP
20:            }
0984  0012     RETURN 0
21:            
22:            inline void enable_master_nco(){
23:                MASTER_NCO_CON |= ENABLE_BIT;
0A2A  0104     MOVLB 0x4
0A2C  8F56     BSF 0x56, 7, BANKED
24:            }
0A2E  0012     RETURN 0
25:            
26:            inline void disable_master_nco(){
27:                MASTER_NCO_CON &= ~ENABLE_BIT;
0A42  0104     MOVLB 0x4
0A44  9F56     BCF 0x56, 7, BANKED
28:            }
0A46  0012     RETURN 0
---  C:/Users/C17239/MPLABXProjects/stepper_test.X/main.c  ----------------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.00
19:             */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
23:                
24:                Subject to your compliance with these terms, you may use Microchip software and any 
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
26:                license terms applicable to your use of third party software (including open source software) that 
27:                may accompany Microchip software.
28:                
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
32:                FOR A PARTICULAR PURPOSE.
33:                
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
41:                SOFTWARE.
42:             */
43:            
44:            #include <pic18f47q84.h>
45:            
46:            #include "mcc_generated_files/mcc.h"
47:            #include "config_macros.h"
48:            #include "platform.h"
49:            #include "stepper.h"
50:            #include "counter.h"
51:            #include "isr.h"
52:            #include "master_clock.h"
53:            
54:            #define STEPS_PER_MM 100
55:            
56:            void InitializeDevice() {
57:                // Initialize the device
58:                SYSTEM_Initialize();
001E  ECFA     CALL 0x9F4, 0
0020  F004     NOP
59:            
60:                TRISAbits.TRISA4 = 0;
0022  98C6     BCF 0xFC6, 4, ACCESS
61:                LATAbits.LATA4 = 0;
0024  98BE     BCF 0xFBE, 4, ACCESS
62:            
63:                SlaveClock y_clock = CreateSlaveClock(NCO_Y_LOC, NCO_Y_PPS);
0026  0E47     MOVLW 0x47
0028  6E01     MOVWF 0x1, ACCESS
002A  0E04     MOVLW 0x4
002C  6E02     MOVWF 0x2, ACCESS
002E  0E3F     MOVLW 0x3F
0030  6E03     MOVWF 0x3, ACCESS
0032  EC62     CALL 0x4C4, 0
0034  F002     NOP
0036  EE21     LFSR 2, 0x646
0038  F246     NOP
003A  0E06     MOVLW 0x6
003C  C4EB     MOVFF PLUSW0, PLUSW2
003E  F4DB     NOP
0040  06E8     DECF 0xFE8, F, ACCESS
0042  E2FC     BC 0x3C
64:                Pin y_enable = InitializePin(
0044  0E00     MOVLW 0x0
0046  6E01     MOVWF 0x1, ACCESS
0048  0E01     MOVLW 0x1
004A  ECA5     CALL 0x54A, 0
004C  F002     NOP
004E  EE21     LFSR 2, 0x64D
0050  F24D     NOP
0052  0E06     MOVLW 0x6
0054  C4EB     MOVFF PLUSW0, PLUSW2
0056  F4DB     NOP
0058  06E8     DECF 0xFE8, F, ACCESS
005A  E2FC     BC 0x54
65:                        Y_ENABLE_PIN_PORT, Y_ENABLE_PIN_POS);
66:                StepPin y_step = InitializeStepPin(
005C  0E01     MOVLW 0x1
005E  6E17     MOVWF 0x17, ACCESS
0060  EE21     LFSR 2, 0x646
0062  F246     NOP
0064  EE01     LFSR 0, 0x518
0066  F118     NOP
0068  0E06     MOVLW 0x6
006A  C4DB     MOVFF PLUSW2, PLUSW0
006C  F4EB     NOP
006E  06E8     DECF 0xFE8, F, ACCESS
0070  E2FC     BC 0x6A
0072  0E02     MOVLW 0x2
0074  6E1F     MOVWF 0x1F, ACCESS
0076  0E03     MOVLW 0x3
0078  EC1D     CALL 0x43A, 0
007A  F002     NOP
007C  EE21     LFSR 2, 0x636
007E  F236     NOP
0080  0E07     MOVLW 0x7
0082  C4EB     MOVFF PLUSW0, PLUSW2
0084  F4DB     NOP
0086  06E8     DECF 0xFE8, F, ACCESS
0088  E2FC     BC 0x82
67:                        Y_STEP_PIN_PORT, Y_STEP_PIN_POS, y_clock, Y_CLC);
68:                Pin y_direction = InitializePin(
008A  0E03     MOVLW 0x3
008C  6E01     MOVWF 0x1, ACCESS
008E  0E03     MOVLW 0x3
0090  ECA5     CALL 0x54A, 0
0092  F002     NOP
0094  EE21     LFSR 2, 0x654
0096  F254     NOP
0098  0E06     MOVLW 0x6
009A  C4EB     MOVFF PLUSW0, PLUSW2
009C  F4DB     NOP
009E  06E8     DECF 0xFE8, F, ACCESS
00A0  E2FC     BC 0x9A
69:                        Y_DIRECTION_PIN_PORT, Y_DIRECTION_PIN_POS);
70:                Pin y_limit = InitializePin(
00A2  0E04     MOVLW 0x4
00A4  6E01     MOVWF 0x1, ACCESS
00A6  0E02     MOVLW 0x2
00A8  ECA5     CALL 0x54A, 0
00AA  F002     NOP
00AC  EE21     LFSR 2, 0x65B
00AE  F25B     NOP
00B0  0E06     MOVLW 0x6
00B2  C4EB     MOVFF PLUSW0, PLUSW2
00B4  F4DB     NOP
00B6  06E8     DECF 0xFE8, F, ACCESS
00B8  E2FC     BC 0xB2
71:                        Y_LIMIT_PIN_PORT, Y_LIMIT_PIN_POS);
72:            
73:                SlaveClock x_clock = CreateSlaveClock(NCO_X_LOC, NCO_X_PPS);
00BA  0E4F     MOVLW 0x4F
00BC  6E01     MOVWF 0x1, ACCESS
00BE  0E04     MOVLW 0x4
00C0  6E02     MOVWF 0x2, ACCESS
00C2  0E40     MOVLW 0x40
00C4  6E03     MOVWF 0x3, ACCESS
00C6  EC62     CALL 0x4C4, 0
00C8  F002     NOP
00CA  EE21     LFSR 2, 0x662
00CC  F262     NOP
00CE  0E06     MOVLW 0x6
00D0  C4EB     MOVFF PLUSW0, PLUSW2
00D2  F4DB     NOP
00D4  06E8     DECF 0xFE8, F, ACCESS
00D6  E2FC     BC 0xD0
74:                Pin x_enable = InitializePin(
00D8  0E05     MOVLW 0x5
00DA  6E01     MOVWF 0x1, ACCESS
00DC  0E01     MOVLW 0x1
00DE  ECA5     CALL 0x54A, 0
00E0  F002     NOP
00E2  EE21     LFSR 2, 0x669
00E4  F269     NOP
00E6  0E06     MOVLW 0x6
00E8  C4EB     MOVFF PLUSW0, PLUSW2
00EA  F4DB     NOP
00EC  06E8     DECF 0xFE8, F, ACCESS
00EE  E2FC     BC 0xE8
75:                        X_ENABLE_PIN_PORT, X_ENABLE_PIN_POS);
76:                StepPin x_step = InitializeStepPin(
00F0  0E05     MOVLW 0x5
00F2  6E17     MOVWF 0x17, ACCESS
00F4  EE21     LFSR 2, 0x662
00F6  F262     NOP
00F8  EE01     LFSR 0, 0x518
00FA  F118     NOP
00FC  0E06     MOVLW 0x6
00FE  C4DB     MOVFF PLUSW2, PLUSW0
0100  F4EB     NOP
0102  06E8     DECF 0xFE8, F, ACCESS
0104  E2FC     BC 0xFE
0106  0E00     MOVLW 0x0
0108  6E1F     MOVWF 0x1F, ACCESS
010A  0E02     MOVLW 0x2
010C  EC1D     CALL 0x43A, 0
010E  F002     NOP
0110  EE21     LFSR 2, 0x63E
0112  F23E     NOP
0114  0E07     MOVLW 0x7
0116  C4EB     MOVFF PLUSW0, PLUSW2
0118  F4DB     NOP
011A  06E8     DECF 0xFE8, F, ACCESS
011C  E2FC     BC 0x116
77:                        X_STEP_PIN_PORT, X_ENABLE_PIN_POS, x_clock, X_CLC);
78:                Pin x_direction = InitializePin(
011E  0E03     MOVLW 0x3
0120  6E01     MOVWF 0x1, ACCESS
0122  0E00     MOVLW 0x0
0124  ECA5     CALL 0x54A, 0
0126  F002     NOP
0128  EE21     LFSR 2, 0x670
012A  F270     NOP
012C  0E06     MOVLW 0x6
012E  C4EB     MOVFF PLUSW0, PLUSW2
0130  F4DB     NOP
0132  06E8     DECF 0xFE8, F, ACCESS
0134  E2FC     BC 0x12E
79:                        X_DIRECTION_PIN_PORT, X_DIRECTION_PIN_POS);
80:                Pin x_limit = InitializePin(
0136  0E03     MOVLW 0x3
0138  6E01     MOVWF 0x1, ACCESS
013A  0E02     MOVLW 0x2
013C  ECA5     CALL 0x54A, 0
013E  F002     NOP
0140  EE21     LFSR 2, 0x677
0142  F277     NOP
0144  0E06     MOVLW 0x6
0146  C4EB     MOVFF PLUSW0, PLUSW2
0148  F4DB     NOP
014A  06E8     DECF 0xFE8, F, ACCESS
014C  E2FC     BC 0x146
81:                        X_LIMIT_PIN_PORT, X_LIMIT_PIN_POS);
82:            
83:            
84:                Stepper y_axis = InitializeStepper(Y_MAX, y_enable, y_step, y_direction, y_limit, Y_BACKWARDS);
014E  0E05     MOVLW 0x5
0150  6E23     MOVWF 0x23, ACCESS
0152  0E14     MOVLW 0x14
0154  6E22     MOVWF 0x22, ACCESS
0156  EE21     LFSR 2, 0x64D
0158  F24D     NOP
015A  EE01     LFSR 0, 0x524
015C  F124     NOP
015E  0E06     MOVLW 0x6
0160  C4DB     MOVFF PLUSW2, PLUSW0
0162  F4EB     NOP
0164  06E8     DECF 0xFE8, F, ACCESS
0166  E2FC     BC 0x160
0168  EE21     LFSR 2, 0x636
016A  F236     NOP
016C  EE01     LFSR 0, 0x52B
016E  F12B     NOP
0170  0E07     MOVLW 0x7
0172  C4DB     MOVFF PLUSW2, PLUSW0
0174  F4EB     NOP
0176  06E8     DECF 0xFE8, F, ACCESS
0178  E2FC     BC 0x172
017A  EE21     LFSR 2, 0x654
017C  F254     NOP
017E  EE01     LFSR 0, 0x533
0180  F133     NOP
0182  0E06     MOVLW 0x6
0184  C4DB     MOVFF PLUSW2, PLUSW0
0186  F4EB     NOP
0188  06E8     DECF 0xFE8, F, ACCESS
018A  E2FC     BC 0x184
018C  EE21     LFSR 2, 0x65B
018E  F25B     NOP
0190  EE01     LFSR 0, 0x53A
0192  F13A     NOP
0194  0E06     MOVLW 0x6
0196  C4DB     MOVFF PLUSW2, PLUSW0
0198  F4EB     NOP
019A  06E8     DECF 0xFE8, F, ACCESS
019C  E2FC     BC 0x196
019E  0E01     MOVLW 0x1
01A0  6E41     MOVWF NVMCON1, ACCESS
01A2  EC24     CALL 0x248, 0
01A4  F001     NOP
01A6  EE21     LFSR 2, 0x600
01A8  F200     NOP
01AA  0E1A     MOVLW 0x1A
01AC  C4EB     MOVFF PLUSW0, PLUSW2
01AE  F4DB     NOP
01B0  06E8     DECF 0xFE8, F, ACCESS
01B2  E2FC     BC 0x1AC
85:                Stepper x_axis = InitializeStepper(X_MAX, x_enable, x_step, x_direction, x_limit, X_BACKWARDS);
01B4  0E09     MOVLW 0x9
01B6  6E23     MOVWF 0x23, ACCESS
01B8  0EC4     MOVLW 0xC4
01BA  6E22     MOVWF 0x22, ACCESS
01BC  EE21     LFSR 2, 0x669
01BE  F269     NOP
01C0  EE01     LFSR 0, 0x524
01C2  F124     NOP
01C4  0E06     MOVLW 0x6
01C6  C4DB     MOVFF PLUSW2, PLUSW0
01C8  F4EB     NOP
01CA  06E8     DECF 0xFE8, F, ACCESS
01CC  E2FC     BC 0x1C6
01CE  EE21     LFSR 2, 0x63E
01D0  F23E     NOP
01D2  EE01     LFSR 0, 0x52B
01D4  F12B     NOP
01D6  0E07     MOVLW 0x7
01D8  C4DB     MOVFF PLUSW2, PLUSW0
01DA  F4EB     NOP
01DC  06E8     DECF 0xFE8, F, ACCESS
01DE  E2FC     BC 0x1D8
01E0  EE21     LFSR 2, 0x670
01E2  F270     NOP
01E4  EE01     LFSR 0, 0x533
01E6  F133     NOP
01E8  0E06     MOVLW 0x6
01EA  C4DB     MOVFF PLUSW2, PLUSW0
01EC  F4EB     NOP
01EE  06E8     DECF 0xFE8, F, ACCESS
01F0  E2FC     BC 0x1EA
01F2  EE21     LFSR 2, 0x677
01F4  F277     NOP
01F6  EE01     LFSR 0, 0x53A
01F8  F13A     NOP
01FA  0E06     MOVLW 0x6
01FC  C4DB     MOVFF PLUSW2, PLUSW0
01FE  F4EB     NOP
0200  06E8     DECF 0xFE8, F, ACCESS
0202  E2FC     BC 0x1FC
0204  0E00     MOVLW 0x0
0206  6E41     MOVWF NVMCON1, ACCESS
0208  EC24     CALL 0x248, 0
020A  F001     NOP
020C  EE21     LFSR 2, 0x61B
020E  F21B     NOP
0210  0E1A     MOVLW 0x1A
0212  C4EB     MOVFF PLUSW0, PLUSW2
0214  F4DB     NOP
0216  06E8     DECF 0xFE8, F, ACCESS
0218  E2FC     BC 0x212
86:            
87:                InitializeMasterClock();
021A  EC1B     CALL 0xA36, 0
021C  F005     NOP
88:            
89:                InitializePlatform(x_axis, y_axis);
021E  EE21     LFSR 2, 0x61B
0220  F21B     NOP
0222  EE01     LFSR 0, 0x5B2
0224  F1B2     NOP
0226  0E1A     MOVLW 0x1A
0228  C4DB     MOVFF PLUSW2, PLUSW0
022A  F4EB     NOP
022C  06E8     DECF 0xFE8, F, ACCESS
022E  E2FC     BC 0x228
0230  EE21     LFSR 2, 0x600
0232  F200     NOP
0234  EE01     LFSR 0, 0x5CD
0236  F1CD     NOP
0238  0E1A     MOVLW 0x1A
023A  C4DB     MOVFF PLUSW2, PLUSW0
023C  F4EB     NOP
023E  06E8     DECF 0xFE8, F, ACCESS
0240  E2FC     BC 0x23A
0242  EC54     CALL 0x6A8, 0
0244  F003     NOP
90:            }
0246  0012     RETURN 0
91:            
92:            /*
93:                                     Main application
94:             */
95:            
96:            void main(void) {
97:            
98:                InitializeDevice();
035C  EC0F     CALL 0x1E, 0
035E  F000     NOP
99:                
100:               __delay_ms(500);
0360  0E29     MOVLW 0x29
0362  6E5E     MOVWF 0x5E, ACCESS
0364  0E96     MOVLW 0x96
0366  6E5D     MOVWF 0x5D, ACCESS
0368  0E7F     MOVLW 0x7F
036A  2EE8     DECFSZ 0xFE8, F, ACCESS
036C  D7FE     BRA 0x36A
036E  2E5D     DECFSZ 0x5D, F, ACCESS
0370  D7FC     BRA 0x36A
0372  2E5E     DECFSZ 0x5E, F, ACCESS
0374  D7FA     BRA 0x36A
0376  F000     NOP
101:           
102:               TRISAbits.TRISA7 = 0;
0378  9EC6     BCF 0xFC6, 7, ACCESS
103:               LATAbits.LATA7 = 0;
037A  9EBE     BCF 0xFBE, 7, ACCESS
104:               
105:               TRISCbits.TRISC6 = 0;
037C  9CC8     BCF 0xFC8, 6, ACCESS
106:               //RC6PPS = 0x42;
107:               RC6PPS = 0;
037E  0E00     MOVLW 0x0
0380  0102     MOVLB 0x2
0382  6F17     MOVWF 0x17, BANKED
108:           
109:           
110:               //home_platform(device);
111:           
112:               set_xy_inc(0x8000, 0x0000);
0384  0E00     MOVLW 0x0
0386  6E2A     MOVWF 0x2A, ACCESS
0388  0E80     MOVLW 0x80
038A  6E2B     MOVWF 0x2B, ACCESS
038C  0E00     MOVLW 0x0
038E  6E2C     MOVWF 0x2C, ACCESS
0390  0E00     MOVLW 0x0
0392  6E2D     MOVWF 0x2D, ACCESS
0394  0E00     MOVLW 0x0
0396  6E2E     MOVWF 0x2E, ACCESS
0398  0E00     MOVLW 0x0
039A  6E2F     MOVWF 0x2F, ACCESS
039C  0E00     MOVLW 0x0
039E  6E30     MOVWF 0x30, ACCESS
03A0  0E00     MOVLW 0x0
03A2  6E31     MOVWF 0x31, ACCESS
03A4  EC25     CALL 0x64A, 0
03A6  F003     NOP
113:           
114:               TRISBbits.TRISB1 = 0;
03A8  92C7     BCF 0xFC7, 1, ACCESS
115:               RB1PPS = 0x41; // NCO3
03AA  0E41     MOVLW 0x41
03AC  0102     MOVLB 0x2
03AE  6F0A     MOVWF 0xA, BANKED
116:           
117:               enable_interrupts();
03B0  EC18     CALL 0xA30, 0
03B2  F005     NOP
118:           
119:               //reset_counter();
120:               
121:               //while(1);
122:           
123:               travel_fixed_speed(0, 0x2000);
03B4  0E00     MOVLW 0x0
03B6  6E06     MOVWF 0x6, ACCESS
03B8  0E00     MOVLW 0x0
03BA  6E05     MOVWF 0x5, ACCESS
03BC  0E00     MOVLW 0x0
03BE  6E07     MOVWF 0x7, ACCESS
03C0  0E20     MOVLW 0x20
03C2  6E08     MOVWF 0x8, ACCESS
03C4  0E00     MOVLW 0x0
03C6  6E09     MOVWF 0x9, ACCESS
03C8  0E00     MOVLW 0x0
03CA  6E0A     MOVWF 0xA, ACCESS
03CC  ECA7     CALL 0x74E, 0
03CE  F003     NOP
124:               
125:               //while(1);
126:           
127:               __delay_ms(100);
03D0  0E09     MOVLW 0x9
03D2  6E5E     MOVWF 0x5E, ACCESS
03D4  0E1E     MOVLW 0x1E
03D6  6E5D     MOVWF 0x5D, ACCESS
03D8  0EE4     MOVLW 0xE4
03DA  2EE8     DECFSZ 0xFE8, F, ACCESS
03DC  D7FE     BRA 0x3DA
03DE  2E5D     DECFSZ 0x5D, F, ACCESS
03E0  D7FC     BRA 0x3DA
03E2  2E5E     DECFSZ 0x5E, F, ACCESS
03E4  D7FA     BRA 0x3DA
03E6  D000     BRA 0x3E8
128:           
129:               travel_fixed_speed(10, 0x1000);
03E8  0E00     MOVLW 0x0
03EA  6E06     MOVWF 0x6, ACCESS
03EC  0E0A     MOVLW 0xA
03EE  6E05     MOVWF 0x5, ACCESS
03F0  0E00     MOVLW 0x0
03F2  6E07     MOVWF 0x7, ACCESS
03F4  0E10     MOVLW 0x10
03F6  6E08     MOVWF 0x8, ACCESS
03F8  0E00     MOVLW 0x0
03FA  6E09     MOVWF 0x9, ACCESS
03FC  0E00     MOVLW 0x0
03FE  6E0A     MOVWF 0xA, ACCESS
0400  ECA7     CALL 0x74E, 0
0402  F003     NOP
130:           
131:               __delay_ms(100);
0404  0E09     MOVLW 0x9
0406  6E5E     MOVWF 0x5E, ACCESS
0408  0E1E     MOVLW 0x1E
040A  6E5D     MOVWF 0x5D, ACCESS
040C  0EE4     MOVLW 0xE4
040E  2EE8     DECFSZ 0xFE8, F, ACCESS
0410  D7FE     BRA 0x40E
0412  2E5D     DECFSZ 0x5D, F, ACCESS
0414  D7FC     BRA 0x40E
0416  2E5E     DECFSZ 0x5E, F, ACCESS
0418  D7FA     BRA 0x40E
041A  D000     BRA 0x41C
132:           
133:               travel_fixed_speed(5, 0x1000);
041C  0E00     MOVLW 0x0
041E  6E06     MOVWF 0x6, ACCESS
0420  0E05     MOVLW 0x5
0422  6E05     MOVWF 0x5, ACCESS
0424  0E00     MOVLW 0x0
0426  6E07     MOVWF 0x7, ACCESS
0428  0E10     MOVLW 0x10
042A  6E08     MOVWF 0x8, ACCESS
042C  0E00     MOVLW 0x0
042E  6E09     MOVWF 0x9, ACCESS
0430  0E00     MOVLW 0x0
0432  6E0A     MOVWF 0xA, ACCESS
0434  ECA7     CALL 0x74E, 0
0436  F003     NOP
134:           
135:               while (1) {
136:                   //LATAbits.LATA4 = 1;
137:                   //LATAbits.LATA7 = !LATAbits.LATA7;
138:               }
0438  D7FF     BRA 0x438
139:           
140:           
141:           
142:               while (1) {
143:           
144:                   //if(get_counter_value(device.master.counter) > 1000){
145:                   //disable_nco(device.master.nco);
146:                   //}
147:           
148:                   if (!BUTTON_2_PORT) {
149:                       //go_steps_manual(&x_axis, STEPS_PER_MM);
150:                       //disable_nco(master.nco);
151:                   } else if (!BUTTON_PORT) {
152:                       //go_steps_manual(&x_axis, -STEPS_PER_MM);
153:                       //disable_nco(master.nco);
154:                   } else {
155:           
156:                   }
157:               }
158:           }
159:           /**
160:            End of File
161:            */
---  C:/Users/C17239/MPLABXProjects/stepper_test.X/isr.c  -----------------------------------------------
1:             /*
2:                 (c) 2019 Microchip Technology Inc. and its subsidiaries. 
3:                 
4:                 Subject to your compliance with these terms, you may use Microchip software and any 
5:                 derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
6:                 license terms applicable to your use of third party software (including open source software) that 
7:                 may accompany Microchip software.
8:                 
9:                 THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
10:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
11:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
12:                FOR A PARTICULAR PURPOSE.
13:                
14:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
15:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
16:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
17:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
18:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
19:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
20:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
21:                SOFTWARE.
22:             */
23:            
24:            /******************************************************/
25:            
26:            #include "isr.h"
27:            #include "config_macros.h"
28:            #include "platform.h"
29:            
30:            void __interrupt() INTERRUPT_InterruptManager(void){
31:                LATAbits.LATA4 = 1;
0A10  88BE     BSF 0xFBE, 4, ACCESS
32:                if(MASTER_SMT_INTERRUPT){
0A12  AAAF     BTFSS 0xFAF, 5, ACCESS
0A14  0011     RETFIE 1
33:                    counter_isr();
0A16  EC53     CALL 0x8A6, 0
0A18  F004     NOP
34:                }
35:            }
0A1A  0011     RETFIE 1
36:            
37:            void enable_interrupts(void){
38:                INTCON0bits.GIEH = 1;
0A30  8ED6     BSF 0xFD6, 7, ACCESS
39:                INTCON0bits.GIEL = 1;
0A32  8CD6     BSF 0xFD6, 6, ACCESS
40:            }
0A34  0012     RETURN 0
---  C:/Users/C17239/MPLABXProjects/stepper_test.X/counter.c  -------------------------------------------
1:             /*
2:                 (c) 2019 Microchip Technology Inc. and its subsidiaries. 
3:                 
4:                 Subject to your compliance with these terms, you may use Microchip software and any 
5:                 derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
6:                 license terms applicable to your use of third party software (including open source software) that 
7:                 may accompany Microchip software.
8:                 
9:                 THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
10:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
11:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
12:                FOR A PARTICULAR PURPOSE.
13:                
14:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
15:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
16:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
17:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
18:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
19:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
20:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
21:                SOFTWARE.
22:             */
23:            
24:            /******************************************************/
25:            
26:            #include "counter.h"
27:            #include "config_macros.h"
28:            
29:            #define CAPTURE_BIT 0x80
30:            #define ENABLE_BIT 0x80
31:            #define RESET_BIT 0x10
32:            
33:            inline void set_counter_pr(uint16_t value){
34:                // Modify MSB first to ensure it doesn't lower overall value midway through
35:                // Assumption is new period value will be higher than current timer value
36:                
37:                MASTER_SMT_PRH = value >> 8;
09B0  F408     NOP
09B2  F30A     NOP
38:                MASTER_SMT_PRL = value & 0xFF;
09B6  F404     NOP
09B8  F309     NOP
39:                MASTER_SMT_PRU = 0;
09BA  0E00     MOVLW 0x0
09BC  6F0B     MOVWF 0xB, BANKED
40:            }
09BE  0012     RETURN 0
41:            
42:            inline void enable_counter(){
43:                MASTER_SMT_CON1 |= ENABLE_BIT;
0A48  8F0D     BSF 0xD, 7, BANKED
44:            }
0A4A  0012     RETURN 0
45:            
46:            inline void disable_counter(){
47:                MASTER_SMT_CON1 &= ~ENABLE_BIT;
48:            }
49:            
50:            void prime_smt(){
51:                MASTER_SMT_CLK = 0b0000;
09E4  0E00     MOVLW 0x0
09E6  6F0F     MOVWF 0xF, BANKED
52:                NOP();
09E8  F000     NOP
53:                NOP();
09EA  F000     NOP
54:                MASTER_SMT_CLK = 0b1000;
09EC  0E08     MOVLW 0x8
09EE  0103     MOVLB 0x3
09F0  6F0F     MOVWF 0xF, BANKED
55:            }
09F2  0012     RETURN 0
56:            
57:            inline void reset_counter(){
58:                //disable_counter();
59:                //SMT1CON1bits.GO = 0;
60:                //MASTER_SMT_STAT |= RESET_BIT;
61:                //SMT1STATbits.RST = 1;
62:                //while(SMT1STATbits.RST);
63:                //SMT1CON1bits.GO = 1;
64:                //enable_counter();
65:                SMT1CON1bits.GO = 0;
099A  0103     MOVLB 0x3
099C  9F0D     BCF 0xD, 7, BANKED
66:                //SMT1TMR = 0;
67:                SMT1TMRL = 0;
099E  0E00     MOVLW 0x0
09A0  6F00     MOVWF group, BANKED
68:                SMT1TMRH = 0;
09A2  0E00     MOVLW 0x0
09A4  6F01     MOVWF 0x1, BANKED
69:                SMT1TMRU = 0;
09A6  0E00     MOVLW 0x0
09A8  6F02     MOVWF 0x2, BANKED
70:                SMT1CON1bits.GO = 1;
09AA  8F0D     BSF 0xD, 7, BANKED
71:            }
09AC  0012     RETURN 0
72:            
73:            void clear_counter_isr(){
74:                MASTER_SMT_IF = 0;
0A4C  9AAF     BCF 0xFAF, 5, ACCESS
75:            }
0A4E  0012     RETURN 0
76:            
77:            void initialize_counter(){
78:                CLKRCONbits.EN = 1;
085C  0100     MOVLB 0x0
085E  8F39     BSF CLKRCON, 7, BANKED
79:                CLKRCLK = 0b01001; // NCO3 1000 NCO2 0111 NCO1
0860  0E09     MOVLW 0x9
0862  6F3A     MOVWF CLKRCLK, BANKED
80:                //MASTER_SMT_CLK = 0b1000;
81:                
82:                MASTER_SMT_CON0 = 0b10100000;
0864  0EA0     MOVLW 0xA0
0866  0103     MOVLB 0x3
0868  6F0C     MOVWF 0xC, BANKED
83:                MASTER_SMT_CON1 = 0b01000000;
086A  0E40     MOVLW 0x40
086C  6F0D     MOVWF 0xD, BANKED
84:                
85:                MASTER_SMT_IE = 1;
086E  8A9F     BSF 0xF9F, 5, ACCESS
86:                
87:                reset_counter();
0870  ECCD     CALL 0x99A, 0
0872  F004     NOP
88:                enable_counter();
0874  EC24     CALL 0xA48, 0
0876  F005     NOP
89:                reset_counter();
0878  ECCD     CALL 0x99A, 0
087A  F004     NOP
90:                
91:                prime_smt();
087C  ECF2     CALL 0x9E4, 0
087E  F004     NOP
92:            }
0880  0012     RETURN 0
93:            
94:            uint16_t get_counter_value(){
95:                MASTER_SMT_STAT |= CAPTURE_BIT;
96:                while(MASTER_SMT_STAT &= CAPTURE_BIT);
97:                
98:                uint16_t result = (MASTER_SMT_RESH << 8) + MASTER_SMT_RESL;
99:                
100:               return result;
101:           }
102:           
103:           void start_counter(uint16_t pr){
104:               reset_counter();
095C  ECCD     CALL 0x99A, 0
095E  F004     NOP
105:               set_counter_pr(pr);
0962  F40C     NOP
0964  F501     NOP
0968  F410     NOP
096A  F502     NOP
096C  ECD7     CALL 0x9AE, 0
096E  F004     NOP
106:           }
0970  0012     RETURN 0
---  C:/Users/C17239/AppData/Local/Temp/s1o6g.s  --------------------------------------------------------
0702  0E24     MOVLW 0x24
0704  6EF6     MOVWF 0xFF6, ACCESS
0706  0E0A     MOVLW 0xA
0708  6EF7     MOVWF 0xFF7, ACCESS
070A  0E00     MOVLW 0x0
070C  6EF8     MOVWF 0xFF8, ACCESS
070E  EE01     LFSR 0, 0x5E8
0712  EE10     LFSR 1, 0x6
0716  0009     TBLRD*+
0718  C4F5     MOVFF TABLAT, POSTINC0
071C  50E5     MOVF 0xFE5, W, ACCESS
071E  50E1     MOVF 0xFE1, W, ACCESS
0720  E1FA     BNZ 0x716
0722  EE01     LFSR 0, 0x67E
0726  0E1B     MOVLW 0x1B
0728  6AEE     CLRF 0xFEE, ACCESS
072A  06E8     DECF 0xFE8, F, ACCESS
072C  E1FD     BNZ 0x728
072E  EE01     LFSR 0, 0x560
0732  0E52     MOVLW 0x52
0734  6AEE     CLRF 0xFEE, ACCESS
0736  06E8     DECF 0xFE8, F, ACCESS
0738  E1FD     BNZ 0x734
073A  0104     MOVLB 0x4
073C  0E08     MOVLW 0x8
073E  6F5D     MOVWF 0x5D, BANKED
0740  0E00     MOVLW 0x0
0742  6F5E     MOVWF 0x5E, BANKED
0744  0E00     MOVLW 0x0
0746  6F5F     MOVWF 0x5F, BANKED
0748  0100     MOVLB 0x0
074A  EFAE     GOTO 0x35C
